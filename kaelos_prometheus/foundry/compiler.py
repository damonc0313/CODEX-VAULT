"""
Foundry Compiler: Build → Sign → Hash → Publish

Implements artifact compilation from specification section 6.
"""

import hashlib
import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
import re

from ..core.models import Artifact, ArtifactKind, Plan, Vow
from .signer import ArtifactSigner


class FoundryCompiler:
    """
    Foundry artifact compiler.
    
    Process per specification section 6:
    1. Synthesize artifact from templates
    2. Lint (PEP8/typing enforcement)
    3. Sign (ed25519) + hash (SHA-256)
    4. Generate provenance manifest
    5. Emit artifact + test vectors
    """
    
    def __init__(self, codex_vault_path: Optional[str] = None):
        self.codex_vault_path = codex_vault_path or "CODEX-VAULT"
        self.signer = ArtifactSigner()
        self.builds: List[Artifact] = []
    
    def compile(
        self,
        plan: Plan,
        kind: ArtifactKind,
        title: str,
        current_vow: Optional[Vow] = None,
        cla_justification: Optional[str] = None
    ) -> Tuple[Artifact, Dict[str, Any]]:
        """
        Compile artifact from plan.
        
        Args:
            plan: Dialectic plan with decomposition
            kind: Artifact kind (spec/code/test/report)
            title: Artifact title
            current_vow: Active vow for CLA checking
            cla_justification: Justification if breaking vow
        
        Returns:
            (artifact, manifest)
        """
        # Vow-Aware Compilation (section 17.3)
        if current_vow and not cla_justification:
            # Check if build would violate vow
            violation = self._check_vow_violation(plan, current_vow)
            if violation:
                raise ValueError(
                    f"Build violates Vow {current_vow.vow_id}: {violation}. "
                    f"Provide CLA justification to proceed."
                )
        
        # Step 1: Synthesize from templates
        content = self._synthesize_artifact(plan, kind, title)
        
        # Step 2: Lint (if code)
        if kind == ArtifactKind.CODE:
            content = self._lint_code(content)
        
        # Step 3: Hash
        content_hash = self._compute_hash(content)
        
        # Step 4: Sign
        signature = self.signer.sign(content_hash)
        
        # Step 5: Generate provenance
        provenance = self._generate_provenance(plan, kind, title, cla_justification)
        
        # Create artifact
        artifact = Artifact(
            id=f"art-{datetime.utcnow().strftime('%Y%m%d-%H%M%S')}-{kind.value[:4]}",
            kind=kind,
            title=title,
            content=content,
            hash=content_hash,
            uri=f"sandbox://artifacts/{title.lower().replace(' ', '_')}",
            signature=signature,
            provenance=provenance
        )
        
        # Generate manifest
        manifest = self._generate_manifest(artifact, plan)
        
        # Store
        self.builds.append(artifact)
        
        return artifact, manifest
    
    def _synthesize_artifact(self, plan: Plan, kind: ArtifactKind, title: str) -> str:
        """Synthesize artifact content from plan decomposition."""
        decomposition = plan.decomposition
        
        if kind == ArtifactKind.SPEC:
            return self._synthesize_spec(plan, decomposition, title)
        elif kind == ArtifactKind.CODE:
            return self._synthesize_code(plan, decomposition, title)
        elif kind == ArtifactKind.TEST:
            return self._synthesize_test(plan, decomposition, title)
        elif kind == ArtifactKind.REPORT:
            return self._synthesize_report(plan, decomposition, title)
        else:
            raise ValueError(f"Unknown artifact kind: {kind}")
    
    def _synthesize_spec(self, plan: Plan, decomp: Dict[str, Any], title: str) -> str:
        """Synthesize specification artifact."""
        semantic = decomp.get('semantic', {})
        structural = decomp.get('structural', {})
        proof = decomp.get('proof', {})
        
        spec = f"""# {title}

## Overview
{plan.thesis}

## Counter-Perspective
{plan.antithesis}

## Ghost Probes
{chr(10).join(f"- {probe}" for probe in plan.ghost_probes)}

## Semantic Layer
{json.dumps(semantic, indent=2)}

## Structural Layer
{json.dumps(structural, indent=2)}

## Proof Layer
{json.dumps(proof, indent=2)}

## Implementation Notes
This specification was synthesized from catalyst `{plan.catalyst_id}` through
dialectical multi-agent synthesis (Gamma-3, Delta-4, Epsilon-5, Don-001).

Time-critical: {plan.time_critical}

---
*Generated by KaelOS Prometheus Foundry*
"""
        return spec
    
    def _synthesize_code(self, plan: Plan, decomp: Dict[str, Any], title: str) -> str:
        """Synthesize code artifact with PEP8/typing compliance."""
        structural = decomp.get('structural', {})
        
        # Generate Python code stub
        code = f'''"""
{title}

Generated by KaelOS Prometheus Foundry.
Catalyst: {plan.catalyst_id}
"""

from typing import Any, Dict, List, Optional
from dataclasses import dataclass


@dataclass
class SynthesizedComponent:
    """Component synthesized from dialectical plan."""
    
    thesis: str
    antithesis: str
    synthesis: Optional[str] = None
    
    def execute(self) -> Dict[str, Any]:
        """
        Execute component logic.
        
        Returns:
            Execution result with metadata
        
        Example:
            >>> comp = SynthesizedComponent("thesis", "antithesis")
            >>> result = comp.execute()
            >>> "synthesis" in result
            True
        """
        # Synthesize from thesis/antithesis
        self.synthesis = f"Synthesis of {{self.thesis}} and {{self.antithesis}}"
        
        return {{
            "thesis": self.thesis,
            "antithesis": self.antithesis,
            "synthesis": self.synthesis,
            "structural": {json.dumps(structural, indent=12)[:-1]}    }}


def main() -> None:
    """Main entry point."""
    comp = SynthesizedComponent(
        thesis="""{plan.thesis[:50]}...""",
        antithesis="""{plan.antithesis[:50]}..."""
    )
    result = comp.execute()
    print(f"Synthesis: {{result['synthesis']}}")


if __name__ == "__main__":
    main()
'''
        return code
    
    def _synthesize_test(self, plan: Plan, decomp: Dict[str, Any], title: str) -> str:
        """Synthesize test artifact."""
        test = f'''"""
Test suite for {title}

Generated by KaelOS Prometheus Foundry.
"""

import pytest
from typing import Any, Dict


def test_synthesis():
    """Test basic synthesis operation."""
    # Test thesis/antithesis handling
    assert True  # Placeholder
    

def test_dialectical_integrity():
    """Verify dialectical integrity."""
    # Ensure ghost probes are addressed
    assert True  # Placeholder


def test_h932_decomposition():
    """Verify H-932 orthogonalization."""
    decomp = {json.dumps(decomp, indent=4)}
    
    assert 'semantic' in decomp
    assert 'structural' in decomp
    assert 'proof' in decomp


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
'''
        return test
    
    def _synthesize_report(self, plan: Plan, decomp: Dict[str, Any], title: str) -> str:
        """Synthesize report artifact."""
        report = f"""# {title}

**Catalyst ID:** {plan.catalyst_id}  
**Time-Critical:** {plan.time_critical}  
**Generated:** {datetime.utcnow().isoformat()}

## Dialectical Summary

### Thesis (Gamma-3)
{plan.thesis}

### Antithesis (Epsilon-5)
{plan.antithesis}

### Ghost Probes (Don-001)
{chr(10).join(f"{i+1}. {probe}" for i, probe in enumerate(plan.ghost_probes))}

## H-932 Decomposition

### Semantic Layer
```json
{json.dumps(decomp.get('semantic', {}), indent=2)}
```

### Structural Layer
```json
{json.dumps(decomp.get('structural', {}), indent=2)}
```

### Proof Layer
```json
{json.dumps(decomp.get('proof', {}), indent=2)}
```

## Recommendations
- Execute plan with H-930 enforcement (Confident Provisionality)
- Maintain H-931 compliance (Ghost novelty)
- Validate H-932 orthogonality

---
*Generated by KaelOS Prometheus Foundry*
"""
        return report
    
    def _lint_code(self, code: str) -> str:
        """
        Lint Python code (basic checks).
        
        Full implementation would integrate pylint/black/mypy.
        """
        # Basic formatting: ensure consistent spacing
        code = code.strip()
        
        # Ensure docstrings present
        if '"""' not in code:
            raise ValueError("Code must include docstrings")
        
        # Ensure type hints present (basic check)
        if 'def ' in code and '->' not in code:
            # Might need type hints
            pass
        
        return code
    
    def _compute_hash(self, content: str) -> str:
        """Compute SHA-256 hash of content."""
        return "sha256:" + hashlib.sha256(content.encode('utf-8')).hexdigest()
    
    def _generate_provenance(
        self,
        plan: Plan,
        kind: ArtifactKind,
        title: str,
        cla_justification: Optional[str]
    ) -> Dict[str, Any]:
        """Generate provenance manifest."""
        return {
            "source": "CODEX-VAULT" if self.codex_vault_path else "synth",
            "inputs": [plan.catalyst_id, plan.id],
            "agents": ["Gamma-3", "Delta-4", "Epsilon-5", "Don-001"],
            "heuristics": ["H-930", "H-931", "H-932"],
            "cla_justification": cla_justification,
            "timestamp": datetime.utcnow().isoformat(),
        }
    
    def _generate_manifest(self, artifact: Artifact, plan: Plan) -> Dict[str, Any]:
        """Generate artifact manifest."""
        return {
            "artifact_id": artifact.id,
            "title": artifact.title,
            "kind": artifact.kind.value,
            "hash": artifact.hash,
            "signature": artifact.signature,
            "provenance": artifact.provenance,
            "plan_id": plan.id,
            "catalyst_id": plan.catalyst_id,
            "test_vectors": self._generate_test_vectors(artifact),
            "verification": {
                "hash_algorithm": "SHA-256",
                "signature_algorithm": "ed25519",
                "reproducible": True,
            }
        }
    
    def _generate_test_vectors(self, artifact: Artifact) -> List[Dict[str, Any]]:
        """Generate test vectors for artifact verification."""
        return [
            {
                "name": "hash_integrity",
                "input": artifact.content[:100],
                "expected_hash_prefix": artifact.hash[:20],
            },
            {
                "name": "signature_valid",
                "hash": artifact.hash,
                "signature": artifact.signature,
            }
        ]
    
    def _check_vow_violation(self, plan: Plan, vow: Vow) -> Optional[str]:
        """
        Check if plan would violate current vow.
        
        Returns violation description or None.
        """
        # Placeholder: In full implementation, would parse vow.text
        # and check against plan constraints
        
        # Example: "No more than 2 smart-layout variants per card"
        if "variant" in vow.text.lower() and "card" in vow.text.lower():
            # Check if plan would create too many variants
            pass
        
        return None  # No violation detected
    
    def get_build_stats(self) -> Dict[str, Any]:
        """Get compilation statistics."""
        return {
            "total_builds": len(self.builds),
            "by_kind": {
                kind.value: len([a for a in self.builds if a.kind == kind])
                for kind in ArtifactKind
            },
            "all_signed": all(a.signature for a in self.builds),
        }
